# Transaction
- 데이터 무결성을 지킴으로써 데이터베이스를 일관된 상태를 유지하기 위한 핵심적인 개념
- DB의 상태를 변경시키기 위해 수행하는 작업 단위를 의미함

## 구성
- 하나 이상의 read operation
- 하나 이상의 write operation
- 트랜잭션 안에서의 데이터 계산 operation

## 트랜잭션의 특성(ACID)
### 원자성(Atomicity)
- 트랜잭션 안의 모든 작업(operation)이 실행되거나 모두 실패
### 일관성(Consistency)
- 트랜잭션의 실행이 데이터베이스의 무결성을 유지
### 격리성(Isolation)
- 동시에 실행되는 트랜잭션은 서로 독립적이거나 순차적으로 실행
### 영속성(Durability)
- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함

## 트랜잭션의 상태
![image](https://github.com/qudwns017/TIL/assets/82150958/f8f6ead8-0fc4-4714-a8b5-d5364c5b6ecc)

## 트랜잭션 스케줄
- 데이터베이스의 일관된 상태를 유지하기 위해 동시에 실행되는 트랜잭션 작업의 순서를 정하는 것

## 트랜잭션 회복
- 트랜잭션 수행 중 장애로 인해 손상된 DB를 이전 상태로 복구시키는 작업
### 회복 연산
- Dump(덤프) : DB 전체를 다른 저장장치에 주기적으로 복사
- Log(로그) : DB의 내용이 갱신될 때마다 데이터 갱신의 이전 값과 이후 값을 별도의 파일에 기록
- Redo(재실행) : DB의 복사본을 가져와 로그를 이용해 장애 발생 직전의 DB 상태로 복구(트랜잭션 완료 전에 장애가 발생한 경우)
- Undo(취소) : 로그를 이용해 실행된 연산을 취소해 DB의 원래 상태로 복구하는 연산(트랜잭션 완료 이후에 장애가 발생한 경우)

### 로그 회복 기법
- 로그 회복 기법
  - 즉시 갱신 회복 기법 : 트랜잭션 수행 중 데이터를 변경한 연산의 결과를 데이터베이스에 즉시 반영하는 경우
  - 지연 갱신 회복 기법 : 트랜잭션이 수행되는 동안에는 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영하지 않고 로그 파일에 기록해두었다가, 트랜잭션이 커밋된 후, 로그의 내용을 기반으로 데이터베이스에 한 번에 반영

### 검사 시점(Checkpoint) 회복 기법
- 로그 회복 기법과 같은 방법으로 로그 기록을 이용하지만, 일정한 시간 간격으로 체크포인트를 만들어둔다. 이후 장애가 발생하면 체크포인트 이전의 트랜잭션에는 회복 작업을 수행하지 않고 이후의 트랜잭션에만 회복 작업을 진행
- 로그 회복 기법의 비효율성을 해결하기 위해 제안됨

### 미디어 회복 기법
- 미디어 회복 기법은 전체 데이터베이스의 내용을 일정한 주기마다 다른 안전한 저장 장치에 복사해두는 덤프를 이용
- 전체 DB의 내용을 다른 저장 장치에 복사하는 것은 비용이 많이 듦
- 복사하는 동안에는 트랜잭션 수행을 중단해야 하므로 CPU가 낭비됨

## 병행 제어
- 트랜잭션이 병행 수행될 때 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것

### 목적
- 데이터베이스의 일관성 유지
- 데이터베이스 공유 최대화
- 시스템 활용도 최대화
- 사용자 응답 시간 최소화
- 단위 시간당 트랜잭션 처리 건수 최대화

### 병행 제어 기법
1. 로킹
- 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 병행 제어 기법
2. 타임스탬프 순서 기법
- 타임스탬프 순서에 따라 트랜잭션들을 직렬화 시키는 방법
3. 낙관적 병행 제어
- 트랜잭션 수행 동안은 어떠한 검사를 하지 않고, 트랜잭션이 종료된 이후에 일괄적으로 검사하는 방식 
4. 다중 버전 병행 제어

## 트랜잭션 격리 수준(Isolation Level)
> 트랜잭션 격리 수준은 여러 트랜잭션이 같은 데이터를 동시에 읽고 쓸 때 생기는 **동시성 문제**를 해결하기 위해 도입 되었으며, **여러 트랜잭션이 동시에 실행됐더라도 그 결과가 트랜잭션이 순차적으로 실행 됐을 때의 결과와 동일함을 보장하는 것**을 목적으로 한다.

### Read Uncommitted(커밋 전 읽기) 격리 수준
> 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 관계 없이 다른 트랜잭션에서 값을 읽어올 수 있는 수준
- 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장
- Dirty Read, Dirty Write 문제가 발생

### Read Committed(커밋 후 읽기) 격리 수준
- 기본적인 격리 수준이며 **커밋 후 읽기**는 아래의 두 가지를 보장한다.
> 1. Read 할 때 커밋된 데이터만 읽는다. (Dirty Read 방지)
> 2. Write 할 때 커밋된 데이터만 덮어쓴다. (Dirty Write 방지)
  - Dirty Read : 아직 커밋 되지 않은 값을 다른 트랜잭션이 읽는 것
  - Dirty Wirte : 아직 커밋 되지 않은 값을 다른 트랜잭션이 덮어 쓰는 것
- 하나의 트랜잭션 내에서 동일한 SELECT 쿼리를 실행했을 때, 쿼리의 결과가 바뀌는 경우(Non-repeatable Read)가 발생할 수 있음
- 위 같은 문제는 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 많은 금전적인 처리와 연결되면 문제가 발생하는 경우가 생김


### Repeatable Read(반복 읽기) 격리 수준
- MySQL의 스토리지 엔진에서 기본적으로 사용되는 격리 수준인 **반복 읽기**는 아래의 두 가지를 보장한다.
> 1. 읽기를 실행하는 트랜잭션이 시작한 시점에 읽으려는 데이터가 커밋되어야만 읽을 수 있다.
> 2. 읽으려는 데이터가 삭제된 것으로 표시되지 않거나, 삭제되었다고 표시는 되었지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 표시를 한 트랜잭션이 커밋되지 않아야 한다.
- 위 사항을 구현하기 위해서 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 한다.
- **MVCC(Multi Version Concurrency Control)** : 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 Undo 영역에 백업해두고 실제 레코드 값을 변경하는 방식
- Reapeatable Read는 Phantom Read의 현상을 막을 수 없다.
- **Phantom Read** : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보였다가 하는 현상

### Serializable(직렬화) 격리 수준
- 가장 단순하면서도 엄격한 격리 수준이며, 동시 처리 성능도 다른 격리 수준보다 현저히 떨어진다.
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 격리 수준

### 트랜잭션 격리 수준에 따라 발생하는 문제점
|격리 수준|DIRTY READ/WRITE|NON-REPEATABLE READ|PHANTOM READ|
|:---:|:---:|:---:|:---:|
|READ UNCOMMITED|O|O|O|
|READ COMMITTED|X|O|O|
|REPEATABLE READ|X|X|O|
|SERIALZABLE|X|X|X|